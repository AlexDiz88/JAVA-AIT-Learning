Мы создаем приложение "Утиный пруд"
1. Первичные задачи:
- создать 4 класса уток (белохвостая утка, красноволосая утка, зеленоголовая утка, скучная серая утка) WhiteTailDuck, RedHairDuck, GreenHeadDuck, BoringGrayDuck.
- каждая утка умеет крякать, метод quack(), плавать swim() и показать информацио об утке, метод display()
quack() - "Я умею крякать, я же уточка. Кря!"
swim() - "Уточка поплыла"
display() -
"Я уточка с белым хвостиком"
"Я не рыжая, а красная! И это мой натуральный цвет!!"
"Я очень ловкая, я утка с зеленой головкой"
"Я скучная серая утка :'("

Создать ArrayList пруд. Создать по одному экземпляру каждой утки и вызвать от каждой методы display() и quack() + добавить "------"

2. Добавить метод fly() всем уткам
"Летящая утка - опасный снаряд! Ю-ху-ууу! ПА-ЛИ-ТЕ-ЛИ!"
Добавить вызов метода fly() в цикл.

3. Добавить класс Резиновая утка - RubberDuck, создать её экземпляр, добавить в наш пруд.
Стоп! Хьюстон у нас проблемы! Но ведь Резиновая утка не умеет летать!? А кряканье резиновой утки похоже на писк.
    quack() - "Я всех раздражаю своим писком. Пьи-пьи-пи!"
    fly() - "Я не умею летать :("
    display() -"Я резиновая желтая уточка, героиня мемов"

4. Добавить класс Деревянная утка - WoodDuck, которая не умеет летать и не умеет ни крякать ни пищать
    quack() - "Я молчалива как бревно"
    fly() - "Я не умею летать :("
    display() -"В голове моей опилки, не беда, деревянная я утка, да-да-да!"

5. Добавить 3 класса уток: глупая, умная и наивная утка. StupidDuck, SmartDuck, NaiveDuck
StupidDuck - не умеет крякать, quack() - "Я молчалива как бревно"
SmartDuck - не умеет летать, fly() - "Я не умею летать :("
NaiveDuck - В силу особенностей голосовых связок - пищит точь-в-точь как резиновая утка
display():
"Я глупая уточка. Ы!"
"Я умная уточка! 2х2=5!"
"Я наивная уточка. А ты правда на мне женишься?"

6. Не надоело переопределять методы? Зачем нам переопределять метод fly() у уток, которые не умеют летать?
Как на счёт интерфейсов?
- Создать интерфейсы Flyable, Quackable
- перенести методы quack() и fly() из родительского класса в интерфейсы.
- имплементировать нужные интрефейсы каждой утке
- перезаписать методы
- исправить вызов методов в мейне, добавив проверку instanceof interface.
- Создать класс уставшая утка - TiredDuck, которая не умеет ни летать ни крякать. display(): "Весь мир тлен. Я устала. Я ухожу.(с) Уставшая уточка"

Ну что, стало немного удобнее? Ведь теперь не надо переписывать методы, которые не реализует класс.

7. А теперь мы решили внести изменения в реализацию полёта.
"Летящая утка - очень опасный снаряд! Ю-ху-хууу! ПО-ЛЕ-ТЕ-ЛИ!"
А еще в реализацию писка quack()
"Я всех раздражаю своим писком. Пьи-пи-пи!"
А теперь представь что у тебя еще 10 разновидностей уток.
А еще представь что изменения - это не одна строка sout, а целый блок кода, который нужно вставить в определенное место реализации метода.
Ты видишь решение этой проблемы?

А теперь магия!
8. Создать интерфейсы поведения: FlyBehavior, QuackBehavior
9. Создать классы FlyWithWings, CantFly, Quack, Squeak, Silenced
- имлементировать интерфейсы FlyBehavior, QuackBehavior
- написать реализацию методов quack() и fly() для каждого класса

10. Добавить в родительский класс содержание состояний flyBehavior, quackBehavior в качестве полей класса.
- добавить методы PerformQuack(), PerformFly() с делегированием поведения ОБЪЕКТУ на который ссылается flyBehavior, quackBehavior

11. Добавить в конструкторы классов начальные значения состояний поведения.
12. Добавить setBehavior в родительский класс.
13. Добавить класс RocketPower имплементирующий FlyBehavior. Напистаь реализацию метода fly()
14. Добавить класс RoboDuck которая летает на ракетном топливе и не крякает.
15. Изменить у умной утки с помощью сеттера способ полета на RocketPower.
Насладиться результатом и масштабом возможностей и свободы!






